import { Node, Edge } from "@xyflow/react";
import { NodeClasses, NodeConfigs } from "../components/nodes/nodeTypes";
import { PropertyDefinition, Var } from "../components/nodes/types";

// Type for node configuration with optional nested attachments
interface NodeConfigWithAttachments {
  type: string | undefined;
  config: Record<string, unknown>;
  attachments?: Record<string, unknown>;
}

// Interface for node config structure
interface NodeConfigStructure {
  properties: PropertyDefinition[];
}

// Finds the 'starting' node
export function findStartingNode(nodes: Node[]): Node | null {
  for (const node of nodes) {
    const nodeClass = NodeClasses[node.type as keyof typeof NodeClasses];

    if (nodeClass && nodeClass.nodeType === "start") {
      return node;
    }
  }

  return null;
}

// Helper function to get connected nodes for a specific handle
export function getConnectedNodes(
  sourceNodeId: string,
  handleId: string,
  edges: Edge[],
  nodes: Node[]
): Node[] {
  const connectedEdges = edges.filter(
    (edge) => edge.source === sourceNodeId && edge.sourceHandle === handleId
  );

  return connectedEdges
    .map((edge) => {
      const targetNode = nodes.find((node) => node.id === edge.target);
      return targetNode;
    })
    .filter((node) => node !== undefined) as Node[];
}

// Helper function to get node configuration with data
export function getNodeConfig(node: Node, edges?: Edge[], nodes?: Node[]) {
  const nodeConfig = NodeConfigs[node.type as keyof typeof NodeConfigs] as unknown as NodeConfigStructure;
  if (!nodeConfig) return {};

  // Merge the node's data with default values from config
  const config: Record<string, unknown> = {};

  // Add all properties from the node config with their values
  nodeConfig.properties.forEach((property: PropertyDefinition) => {
    const value =
      node.data?.[property.key] !== undefined
        ? node.data[property.key]
        : property.defaultValue;
    config[property.key] = value;
  });

  // Special handling for group and theme creator nodes: convert selected prompt IDs to backend format
  if ((node.type === 'group' || node.type === 'themeCreator') && edges && nodes) {
    const selectedPromptIds = config['selected_submission_prompts'] as string[] || [];
    
    if (selectedPromptIds.length > 0) {
      // Get all submission prompt variables from the workflow
      const submissionPromptVars = getSubmissionPromptVariables(nodes, edges);
      
      // Convert prompt IDs to backend format with details
      const selectedPromptDetails: Array<{
        id: string;
        variableName: string;
        origin: string;
        origin_type: string;
        type: string;
        page: number;
        index: number;
      }> = [];
      
      selectedPromptIds.forEach(promptId => {
        // Parse prompt ID format: ${submissionNodeId}-prompt-${index}
        const promptIdMatch = promptId.match(/^(.+)-prompt-(\d+)$/);
        if (promptIdMatch) {
          const [, submissionNodeId, promptIndex] = promptIdMatch;
          
          // Find the prompt node that connects to this submission node
          const promptEdge = edges.find(edge => 
            edge.target === submissionNodeId && 
            edge.targetHandle === 'prompt-input' &&
            edge.sourceHandle === 'prompt-output'
          );
          
          if (promptEdge) {
            const promptNode = nodes.find(n => n.id === promptEdge.source);
            if (promptNode && promptNode.type === 'prompt') {
              // Find all variables generated by this prompt node
              const promptNodeVariables = submissionPromptVars.filter(variable => {
                // Parse variable name: prompt_${pageNumber}_${type}_${index}
                const variableMatch = variable.name.match(/^prompt_(\d+)_([^_]+)_(\d+)$/);
                if (variableMatch) {
                  const [, , , varIndex] = variableMatch;
                  // Match by index - this should correspond to the position in submission_prompts array
                  return varIndex === promptIndex;
                }
                return false;
              });
              
              // Filter to only variables that could be generated by this specific prompt node
              const relevantVariables = promptNodeVariables.filter(variable => {
                // Get the page number from the variable name
                const variableMatch = variable.name.match(/^prompt_(\d+)_([^_]+)_(\d+)$/);
                if (variableMatch) {
                  const [, pageNumber] = variableMatch;
                  
                  // Check if this prompt node would generate a variable with this page number
                  // by checking its page context
                  try {
                    const nodeClass = NodeClasses['prompt'];
                    if (nodeClass) {
                      // eslint-disable-next-line @typescript-eslint/no-explicit-any
                      const tempInstance = new (nodeClass as any)({ id: promptNode.id, data: promptNode.data, edges });
                      const nodePageId = tempInstance.getCurrentPageId();
                      return nodePageId === pageNumber;
                    }
                  } catch {
                    // If we can't determine the page, assume it's correct if it matches our pattern
                    return true;
                  }
                }
                return false;
              });
              
              // Add the matching variables
              relevantVariables.forEach(variable => {
                selectedPromptDetails.push({
                  id: variable.name, // Use variable name as ID
                  variableName: variable.name,
                  origin: variable.origin,
                  origin_type: variable.origin_type,
                  type: variable.type,
                  page: variable.page,
                  index: variable.index,
                });
              });
            }
          }
        }
      });
      
      // Replace the prompt ID array with full variable details for the backend
      config['selected_submission_prompts'] = selectedPromptDetails;
    }
  }

  // Special handling for live presentation prompt nodes: convert list variable IDs in prompts to backend format
  if (node.type === 'livePresentationPrompt' && edges && nodes) {
    const savedPrompts = config['saved_prompts'] as Array<{
      id: string;
      statement: string;
      hasInput: boolean;
      inputType?: string;
      inputPlaceholder?: string;
      useRandomListItem?: boolean;
      listVariableId?: string;
    }> || [];
    
    // Get all list variables from behaviors in the workflow for lookup
    const behaviorListVars = getListVariablesFromBehaviors(nodes, edges);
    
    // Process each prompt to convert listVariableId to full variable details
    const processedPrompts = savedPrompts.map(prompt => {
      if (prompt.useRandomListItem && prompt.listVariableId) {
        // Find the variable details for this listVariableId
        const variable = behaviorListVars.find(v => v.name === prompt.listVariableId);
        if (variable) {
          return {
            ...prompt,
            // Replace listVariableId with full variable details for the backend
            listVariable: {
              id: variable.name,
              variableName: variable.name,
              origin: variable.origin,
              origin_type: variable.origin_type,
              type: variable.type,
              page: variable.page,
              index: variable.index,
            }
          };
        }
      }
      return prompt;
    });
    
    // Update the config with processed prompts
    config['saved_prompts'] = processedPrompts;
  }

  return config;
}

// Helper function to find all submission nodes connected via behavior/page nodes
export function findConnectedSubmissionNodes(
  groupNodeId: string,
  edges: Edge[],
  nodes: Node[],
  pageRelationships?: Record<string, string[]>
): Node[] {
  const submissionNodes: Node[] = [];
  const visitedNodes = new Set<string>();

  // First, let's check if there are ANY submission nodes in the entire workflow
  const allSubmissionNodes = nodes.filter(node => node.type === 'submission');

  // Helper function to recursively traverse connections
  function traverseConnections(nodeId: string, depth = 0) {
    if (visitedNodes.has(nodeId) || depth > 10) return; // Prevent infinite loops and limit depth
    visitedNodes.add(nodeId);

    const node = nodes.find(n => n.id === nodeId);
    if (!node) {
      return;
    }
    
    // Check if this node has any outgoing edges to see what it connects to
    const outgoingEdges = edges.filter(edge => edge.source === nodeId);

    // If this is a submission node, add it to our collection
    if (node.type === 'submission') {
      submissionNodes.push(node);
      return;
    }

    // If this is a page or behaviour node, check nodes inside it
    if ((node.type === 'page' || node.type === 'behaviour') && pageRelationships) {
      const nodesInContainer = pageRelationships[nodeId] || [];
      nodesInContainer.forEach(containedNodeId => {
        traverseConnections(containedNodeId, depth + 1);
      });
    }

    // Follow outgoing connections from this node (but don't re-filter, we already have them)
    outgoingEdges.forEach(edge => {
      traverseConnections(edge.target, depth + 1);
    });
  }

  // Start traversal from the group node's output connections
  const groupOutputEdges = edges.filter(edge => 
    edge.source === groupNodeId && edge.sourceHandle === 'group-output'
  );
  
  groupOutputEdges.forEach(edge => {
    traverseConnections(edge.target);
  });

  // FALLBACK: Check if there are any submission nodes that exist but weren't found by traversal
  // This can happen if pageRelationships data is out of sync OR if submission nodes are in separate flows
  if (submissionNodes.length === 0 && allSubmissionNodes.length > 0) {
    // For grouping purposes, we should include ALL submission nodes that are reachable
    // from the same page structure that the group node can access
    submissionNodes.push(...allSubmissionNodes);
  }

  return submissionNodes;
}

// Helper function to extract all submission prompts from submission nodes
export function getAvailableSubmissionPrompts(
  groupNodeId: string,
  edges: Edge[],
  nodes: Node[],
  pageRelationships?: Record<string, string[]>
): Array<{ nodeId: string; nodeLabel: string; prompts: Array<{ id: string; prompt: string; mediaType: string }> }> {
  const submissionNodes = findConnectedSubmissionNodes(groupNodeId, edges, nodes, pageRelationships);
  
  return submissionNodes.map(node => {
    const nodeData = node.data as { label?: string; submission_prompts?: Array<{ prompt?: string; mediaType?: string }> };
    const submissionPrompts = nodeData?.submission_prompts || [];
    
    return {
      nodeId: node.id,
      nodeLabel: nodeData?.label || `Submission Node ${node.id.slice(0, 8)}`,
      prompts: submissionPrompts.map((prompt, index: number) => ({
        id: `${node.id}-prompt-${index}`,
        prompt: prompt.prompt || '',
        mediaType: prompt.mediaType || 'textarea'
      }))
    };
  }).filter(nodeInfo => nodeInfo.prompts.length > 0);
}

// Helper function to get attachments for specific node types (recursive)
export function getNodeAttachments(
  node: Node,
  edges: Edge[],
  nodes: Node[],
  visitedNodes: Set<string> = new Set()
): Record<string, unknown> | undefined {
  // Prevent infinite loops
  if (visitedNodes.has(node.id)) {
    return undefined;
  }
  
  visitedNodes.add(node.id);

  if (node.type === "agent") {
    const attachments: Record<string, unknown> = {};

    // Get LLM model attachments
    const llmNodes = getConnectedNodes(node.id, "llm-model", edges, nodes);
    if (llmNodes.length > 0) {
      attachments.llmModel = llmNodes.map((llmNode) => {
        const nodeConfig: NodeConfigWithAttachments = {
          type: llmNode.type,
          config: getNodeConfig(llmNode, edges, nodes),
        };
        
        // Recursively get attachments of the LLM node
        const nestedAttachments = getNodeAttachments(llmNode, edges, nodes, new Set(visitedNodes));
        if (nestedAttachments) {
          nodeConfig.attachments = nestedAttachments;
        }
        
        return nodeConfig;
      });
    }

    // Get tools attachments
    const toolNodes = getConnectedNodes(node.id, "tools", edges, nodes);
    if (toolNodes.length > 0) {
      attachments.tools = toolNodes.map((toolNode) => {
        const nodeConfig: NodeConfigWithAttachments = {
          type: toolNode.type,
          config: getNodeConfig(toolNode, edges, nodes),
        };
        
        // Recursively get attachments of the tool node
        const nestedAttachments = getNodeAttachments(toolNode, edges, nodes, new Set(visitedNodes));
        if (nestedAttachments) {
          nodeConfig.attachments = nestedAttachments;
        }
        
        return nodeConfig;
      });
    }

    return Object.keys(attachments).length > 0 ? attachments : undefined;
  } else if (node.type === "code") {
    const attachments: Record<string, unknown> = {};
    const testsNodes = getConnectedNodes(node.id, "tests-input", edges, nodes);
    if (testsNodes.length > 0) {
      attachments.tests = testsNodes.map((testsNode) => {
        const nodeConfig: NodeConfigWithAttachments = {
          type: testsNode.type,
          config: getNodeConfig(testsNode, edges, nodes),
        };
        
        // Recursively get attachments of the tests node
        const nestedAttachments = getNodeAttachments(testsNode, edges, nodes, new Set(visitedNodes));
        if (nestedAttachments) {
          nodeConfig.attachments = nestedAttachments;
        }
        
        return nodeConfig;
      });
    }
    
    return Object.keys(attachments).length > 0 ? attachments : undefined;
  } else if (node.type === "tests") {
    const attachments: Record<string, unknown> = {};
    
    // Get code analyzer attachments
    const codeAnalyzerNodes = getConnectedNodes(node.id, "analyzer-output", edges, nodes);
    if (codeAnalyzerNodes.length > 0) {
      attachments.codeAnalyzers = codeAnalyzerNodes.map((analyzerNode) => {
        const nodeConfig: NodeConfigWithAttachments = {
          type: analyzerNode.type,
          config: getNodeConfig(analyzerNode, edges, nodes),
        };
        
        // Recursively get attachments of the code analyzer node
        const nestedAttachments = getNodeAttachments(analyzerNode, edges, nodes, new Set(visitedNodes));
        if (nestedAttachments) {
          nodeConfig.attachments = nestedAttachments;
        }
        
        return nodeConfig;
      });
    }
    
    return Object.keys(attachments).length > 0 ? attachments : undefined;
  } else if (node.type === "codeAnalyzer") {
    const attachments: Record<string, unknown> = {};
    
    // Get LLM model attachments for code analyzer
    const llmNodes = getConnectedNodes(node.id, "llm-model", edges, nodes);
    if (llmNodes.length > 0) {
      attachments.llmModel = llmNodes.map((llmNode) => {
        const nodeConfig: NodeConfigWithAttachments = {
          type: llmNode.type,
          config: getNodeConfig(llmNode, edges, nodes),
        };
        
        // Recursively get attachments of the LLM node
        const nestedAttachments = getNodeAttachments(llmNode, edges, nodes, new Set(visitedNodes));
        if (nestedAttachments) {
          nodeConfig.attachments = nestedAttachments;
        }
        
        return nodeConfig;
      });
    }
    
    return Object.keys(attachments).length > 0 ? attachments : undefined;
  } else if (node.type === "mcq") {
    const attachments: Record<string, unknown> = {};
    
    // Get questions attachments
    const questionsNodes = getConnectedNodes(node.id, "mcq-output", edges, nodes);
    if (questionsNodes.length > 0) {
      attachments.questions = questionsNodes.map((questionsNode) => {
        const nodeConfig: NodeConfigWithAttachments = {
          type: questionsNode.type,
          config: getNodeConfig(questionsNode, edges, nodes),
        };
        
        // Recursively get attachments of the questions node
        const nestedAttachments = getNodeAttachments(questionsNode, edges, nodes, new Set(visitedNodes));
        if (nestedAttachments) {
          nodeConfig.attachments = nestedAttachments;
        }
        
        return nodeConfig;
      });
    }
    
    return Object.keys(attachments).length > 0 ? attachments : undefined;
  }

  return undefined;
}

// Helper function to get all variables from all nodes in the workflow using nodeVariables method
export function getAllVariables(nodes: Node[], edges: Edge[]): Var[] {
  const allVariables: Var[] = [];
  
  nodes.forEach((node) => {
    try {
      const nodeType = node.type;
      const NodeClass = nodeType ? NodeClasses[nodeType as keyof typeof NodeClasses] : null;
      
      if (NodeClass) {
        // Create a temporary instance with the node's props
        const nodeInstance = new (NodeClass as new (props: { id: string; data: unknown; edges: Edge[] }) => { nodeVariables: (nodes: Node[]) => Var[] })({
          id: node.id,
          data: node.data,
          edges: edges,
        });
        
        // Call the nodeVariables method
        const variables = nodeInstance.nodeVariables(nodes);
        allVariables.push(...variables);
      }
    } catch (error) {
      console.error(`Error getting variables from node ${node.id}:`, error);
    }
  });
  
  return allVariables;
}

// Helper function to get submission prompt variables (origin: "prompt", origin_type: "student")
export function getSubmissionPromptVariables(nodes: Node[], edges: Edge[]): Var[] {
  const allVariables = getAllVariables(nodes, edges);
  
  return allVariables.filter(variable => 
    variable.origin === "prompt" && variable.origin_type === "student"
  );
}

// Helper function to get list variables from behaviors (origin_type: "behaviour", type: "list")
export function getListVariablesFromBehaviors(nodes: Node[], edges: Edge[]): Var[] {
  const allVariables = getAllVariables(nodes, edges);
  
  return allVariables.filter(variable => 
    variable.origin_type === "behaviour" && variable.type === "list"
  );
}

// Create an index of variable names output by each behavior and page
export function createVariableIndex(nodes: Node[], edges: Edge[]): {
  behaviors: Record<number, string[]>;
  pages: Record<number, string[]>;
} {
  const allVariables = getAllVariables(nodes, edges);
  
  const behaviorIndex: Record<number, string[]> = {};
  const pageIndex: Record<number, string[]> = {};
  
  // Get all behavior and page nodes to understand the structure
  const behaviorNodes = nodes.filter(node => node.type === 'behaviour');
  const pageNodes = nodes.filter(node => node.type === 'page');
  
  // Initialize indexes with empty arrays for all behavior and page numbers
  behaviorNodes.forEach(node => {
    const pageNumber = (node.data as { pageNumber?: number })?.pageNumber || 1;
    if (!behaviorIndex[pageNumber]) {
      behaviorIndex[pageNumber] = [];
    }
  });
  
  pageNodes.forEach(node => {
    const pageNumber = (node.data as { pageNumber?: number })?.pageNumber || 1;
    if (!pageIndex[pageNumber]) {
      pageIndex[pageNumber] = [];
    }
  });
  
  // Group variables by their page numbers and origin types
  allVariables.forEach(variable => {
    const pageNumber = variable.page;
    
    if (variable.origin_type === "behaviour") {
      // This variable is output by a behavior
      if (!behaviorIndex[pageNumber]) {
        behaviorIndex[pageNumber] = [];
      }
      if (!behaviorIndex[pageNumber].includes(variable.name)) {
        behaviorIndex[pageNumber].push(variable.name);
      }
    } else if (variable.origin_type === "student") {
      // This variable is output by a page (student submissions)
      if (!pageIndex[pageNumber]) {
        pageIndex[pageNumber] = [];
      }
      if (!pageIndex[pageNumber].includes(variable.name)) {
        pageIndex[pageNumber].push(variable.name);
      }
    }
  });
  
  // Sort variable names within each index for consistency
  Object.keys(behaviorIndex).forEach(pageNum => {
    behaviorIndex[parseInt(pageNum)].sort();
  });
  
  Object.keys(pageIndex).forEach(pageNum => {
    pageIndex[parseInt(pageNum)].sort();
  });
  
  return {
    behaviors: behaviorIndex,
    pages: pageIndex
  };
}
